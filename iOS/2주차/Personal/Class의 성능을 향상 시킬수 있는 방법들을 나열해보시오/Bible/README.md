# Class의 성능을 향상 시킬수 있는 방법들을 나열해보시오.

먼저 결론부터 말하면 class에 **final** 혹은 **private** 키워드를 붙이면 성능을 향상시킬 수 있습니다.

### 접근 제어
이러한 키워드는 **Access Control** 즉, 접근 제어를 하기 위해 쓰이는 키워드인데요  
다른 소스파일, 코드에서 어떠한 코드의 전체나 일부에 대한 접근을 제한합니다.  
  
접근을 제한한다는 말은 A 클래스에 선언되어 있는 함수나 변수를 B 클래스에서 사용하게 하거나 못 하게 제어하는 것입니다.  
  
클래스나 구조체, 열거형 자체를 접근 제어하거나 이 안에 선언되어 있는 함수, 변수 등등에 대해서 모두 접근 제어가 가능합니다. 선언 시 앞에 키워드를 붙여서 사용하면 됩니다.  

```swift
public class TestClass {
	final let testStr: String = "test"
	private var testInt: Int = 0
	private func testFunc() { print("TEST") }
}
```
(이러한 접근 제어는 객체 지향의 특징 중 하나인 은닉화를 가능하게 해줍니다.  
은닉화란 객체 내부의 데이터, 자료들의 접근을 제한하여 은닉(hiding) 시키는 것입니다.  
외부에서는 이 데이터에 어떤 값이 있는지 모른채 수정, 조작하는 동작을 내부의 메서드(getter, setter)만을 통해서 결과만 전달 받을 수 있게 됩니다.)  
  
### Dispatch
먼저 Dispatch의 사전적인 의미는 ‘보내다’, ‘전송하다’ 이런 뜻을 가지고 있습니다.  
Dispatch는 어떤 상황에서 어떤 메서드를 호출(전송)할 것인지를 결정하고 실행하는 매커니즘으로  Dynamic Dispatch(동적), Static Dispatch(정적) 두 가지의 방식이 있습니다.  
- **Static Dispatch**는 컴파일 시점에 호출 할 함수를 결정합니다.
컴파일 시점이란 앱을 동작 시키기 전에 개발자가 작성한 코드들이 컴퓨터가 읽을 수 있게 만들어서 앱 실행을 준비하는 과정입니다. 
앱 실행 전, 어떤 상황에서 이 함수가 호출 될 것이라는 결정이 나기 때문에 성능이 좋습니다.
- **Dynamic Dispatch**는 런타임 시점에 호출 할 함수를 결정합니다.
컴파일이 끝난 후 앱을 실행하는 동안 일어나는 과정(런타임) 속에서 호출 함수를 정하게 되는데, 이 경우는 하위 클래스가 상위 클래스의 매서드를 호출할 때 해당 배열을 참조하여 호출하는 함수를 결정하는 과정을 런타임에 결정하고 성능은 떨어지게 됩니다.
  
이러한 특성으로 참조 타입(상속 기능이 있는 Class)은 Dynamic Dispatch, 값 타입(Struct)은 Static Dispatch를 사용합니다.  
  
따라서 Dynamic Dispatch를 사용하기에 성능이 떨어지는 class를 Static Dispatch처럼 기능을 하도록 하면 성능이 좋아지겠죠!  

## 결론
class의 성능을 향상시키기 위해서는,  
1. 상속이나 오버라이딩이 필요 없는 클래스나 매서드, 프로퍼티에 **final** 선언  
final이 붙은 매서드나 프로퍼티는 하위 클래스에서 이들을 오버라이딩 할 수 없게 되고, class에 final이 붙으면 상속 자체가 불가능해져서 Static Dispatch로 동작하게 됩니다.

2. 파일 내에서만 접근해도 되는 경우에는 **private** 선언  
private로 선언하게 되면 참조 가능한 범위가 private로 선언된 파일 혹은 블록 내에서만 가능하게 됩니다. 컴파일러는 private가 붙은 프로퍼티에 대해서 오버라이드가 될 수 있는지 없는지를 판단해 오버라이드하는 곳이 없다면 final 키워드로 추론하게 됩니다.
class 앞에 private 키워드를 붙이면 클래스 내부의 모든 프로퍼티, 메서드에 private 키워드가 붙은 것으로 동작하게 됩니다.

## 번외
### struct를 Dynamic Dispatch로 사용 가능?
구조체는 값타입이어서 기본적으로 Static Dispatch 방식으로 작동이 됩니다.  
구조체가 Dynamic Dispatch 방식으로 작동하게 될 경우는 프로토콜을 채택했을 때 입니다.  
프로토콜은 이 함수를 구현해줘~! 하고 작성해놓으면 이 프로토콜을 채택한 클래스나 구조체는 저 프로토콜에 작성된 함수를 사용해야하는데,  
프로토콜은 참조 타입이라 Dynamic Dispatch 방식으로 작동하게 되고,  
어떤 구조체가 프로토콜을 채택해서 프로토콜의 함수를 사용하게 된다면 이 때는 Dynamic Dispatch 방식으로 작동하게 됩니다.
